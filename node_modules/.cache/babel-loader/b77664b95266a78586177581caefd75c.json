{"ast":null,"code":"if (process.fiberLib) {\n  module.exports = process.fiberLib;\n} else {\n  var fs = require('fs'),\n      path = require('path'),\n      detectLibc = require('detect-libc'); // Seed random numbers [gh-82]\n\n\n  Math.random(); // Look for binary for this platform\n\n  var modPath = path.join(__dirname, 'bin', process.platform + '-' + process.arch + '-' + process.versions.modules + (process.platform === 'linux' ? '-' + detectLibc.family : ''), 'fibers');\n\n  try {\n    // Pull in fibers implementation\n    process.fiberLib = module.exports = require(modPath).Fiber;\n  } catch (ex) {\n    // No binary!\n    console.error('## There is an issue with `node-fibers` ##\\n' + '`' + modPath + '.node` is missing.\\n\\n' + 'Try running this to fix the issue: ' + process.execPath + ' ' + __dirname.replace(' ', '\\\\ ') + '/build');\n    console.error(ex.stack || ex.message || ex);\n    throw new Error('Missing binary. See message above.');\n  }\n\n  setupAsyncHacks(module.exports);\n}\n\nfunction setupAsyncHacks(Fiber) {\n  // Older (or newer?) versions of node may not support this API\n  try {\n    var aw = process.binding('async_wrap');\n    var getAsyncIdStackSize;\n\n    if (aw.asyncIdStackSize instanceof Function) {\n      getAsyncIdStackSize = aw.asyncIdStackSize;\n    } else if (aw.constants.kStackLength !== undefined) {\n      getAsyncIdStackSize = function (kStackLength) {\n        return function () {\n          return aw.async_hook_fields[kStackLength];\n        };\n      }(aw.constants.kStackLength);\n    } else {\n      throw new Error('Couldn\\'t figure out how to get async stack size');\n    }\n\n    if (!aw.popAsyncIds || !aw.pushAsyncIds) {\n      throw new Error('Push/pop do not exist');\n    }\n\n    var kExecutionAsyncId;\n\n    if (aw.constants.kExecutionAsyncId === undefined) {\n      kExecutionAsyncId = aw.constants.kCurrentAsyncId;\n    } else {\n      kExecutionAsyncId = aw.constants.kExecutionAsyncId;\n    }\n\n    var kTriggerAsyncId;\n\n    if (aw.constants.kTriggerAsyncId === undefined) {\n      kTriggerAsyncId = aw.constants.kCurrentTriggerId;\n    } else {\n      kTriggerAsyncId = aw.constants.kTriggerAsyncId;\n    }\n\n    var asyncIds = aw.async_id_fields || aw.async_uid_fields;\n\n    function getAndClearStack() {\n      var ii = getAsyncIdStackSize();\n      var stack = new Array(ii);\n\n      for (; ii > 0; --ii) {\n        var asyncId = asyncIds[kExecutionAsyncId];\n        stack[ii - 1] = {\n          asyncId: asyncId,\n          triggerId: asyncIds[kTriggerAsyncId]\n        };\n        aw.popAsyncIds(asyncId);\n      }\n\n      return stack;\n    }\n\n    function restoreStack(stack) {\n      for (var ii = 0; ii < stack.length; ++ii) {\n        aw.pushAsyncIds(stack[ii].asyncId, stack[ii].triggerId);\n      }\n    }\n\n    function wrapFunction(fn) {\n      return function () {\n        var stack = getAndClearStack();\n\n        try {\n          return fn.apply(this, arguments);\n        } finally {\n          restoreStack(stack);\n        }\n      };\n    } // Monkey patch methods which may long jump\n\n\n    Fiber.yield = wrapFunction(Fiber.yield);\n    Fiber.prototype.run = wrapFunction(Fiber.prototype.run);\n    Fiber.prototype.throwInto = wrapFunction(Fiber.prototype.throwInto);\n  } catch (err) {\n    return;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}